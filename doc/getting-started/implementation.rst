Working with docker
===================

Now that the docker image is downloaded to your local machine, you can start it
with the docker command:

.. code-block::

	docker run -ti swedishembedded/develop:latest
	SDK /build >

You are now "inside" the docker environment. All commands you run here are local
to the docker environment.

Go to the /build/platform/sdk directory:

.. code-block::

	cd platform/sdk

Building your first example
===========================

You can now build any example application within both the SDK and zephyr (zephyr
comes with a whole lot of examples under /build/platform/zephyr/samples).

Go ahead and build the SPI gpio driver sample:

.. code-block::

	west build -b custom_board samples/drivers/gpio/mcp23s17

Here we are compiling the sample for the "custom_board" board. This is a
customized stm32 nucleo board target with simulation support added to it.

This application starts a serial shell console on STM32 UART2.

You can start this application in the simulator using west. In fact, if you
supply "-t" parameter to west build, you can run a "target" which you pass after
-t:

.. code-block::

	west build -b custom_board samples/drivers/gpio/mcp23s17 -t simulate

There are several predefined targets that you can run:

- **simulate**: starts a simulation in renode
- **simulate-debugserver**: starts a simulation and also a debugserver on port 3333
- **flash**: flashes the firmware to a board connected over JTAG
- **menuconfig**: fires up configuration menu where you can configure current build

If you just run the simulation, you will see that the UART2 output is being
printed out to the console.

The simulation for this particular sample also creates a virtual terminal called
"usart2" in the build direction (default build folder is "build") and connects
it to the simulated STM32 USART2. This allows you to connect to this virtual
terminal as though it was a USB to Serial connection to the real board:

.. code-block::

	picocom build/usart2
	usart:~$

And now you can interact with the shell built into this sample! (try typing
"help").

Once you want to exit picocom you can press C-a+q.

Debugging your application
==========================

If you instead run the "simulate-debugserver" target, you will start the
simulation and also you will have a GDB debug server running on localhost
port 3333.

.. code-block::

	west build -b custom_board samples/drivers/gpio/mcp23s17 \
		-t simulate-debugserver

You can now debug the application using gdb dashboard. The dashboard is
accessible through "debug" alias command. It accepts the same arguments as gdb,
but also loads the graphical interface which makes debugging easier:

.. code-block::

	debug build/zephyr/zephyr.elf

Once you are inside gdb, you need to tell it which running instance to debug.
Since we have a gdb server running inside the simulator, we can connect to it
like this:

.. code-block::

	(gdb) target remote :3333

Renode commands are now accessible from GDB using the "monitor" command (or
"mon" for short):

To get help on the available commands you can type:

.. code-block::

	(gdb) mon help

Flashing on real hardware
=========================

You can also flash the application on the real nucleo board. For this you will
need to expose USB to the docker image so you can connect to your JTAG adapter.
This can be done by running the docker image in privileged mode and mounting usb
devices. On linux this can be done like this:

.. code-block:: shell

	docker run -t -i --privileged -v /dev/bus/usb:/dev/bus/usb \
		swedishembedded/develop:latest

Now you should be able to flash a sample application like this:

.. code-block:: shell

	west build -b stm32f429i_disc1 ../zephyr/samples/basic/blinky \
		-t flash

For a list of boards you can execute:

.. code-block:: shell

	west boards

Note that not all applications support all of the boards. Specially not ones
that rely on external peripherals. This means that you may not be able to build
them unless the app is configured to support the target board.

Building and running tests
==========================

The SDK comes with several samples and tests which are required to verify that
all drivers and libraries are in good shape. These tests typically run
automatically for every merge request in CI. You can execute these build
commands yourself as well:

This builds all samples:

.. code-block::

	./scripts/build

This builds and executes all unit and integration tests:

.. code-block::

	./scripts/test

This command checks the state of the repository for errors:

.. code-block::

	./scripts/check

To see coverage report after running test script you can open
build-tests/coverage-project/index.html in your browser. This is the report
generated by lcov only for files within the SDK without including any Zephyr
sources.
